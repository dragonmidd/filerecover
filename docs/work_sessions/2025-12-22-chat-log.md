<!--
自动生成：会话日志保存（从启动到当前进度）
路径：docs/work_sessions/2025-12-22-chat-log.md
用途：把关键聊天记录、决策、变更与下一步全部记录在仓库，便于审计与明日继续工作。
-->

# 会话日志 (2025-12-22)

概述：
- 项目：`filerecover`（Windows 文件恢复引擎原型）
- 目的：将本次从项目启动到当前的全部聊天室关键信息、修复记录和下一步计划保存到仓库，便于延续开发与审计。

---

## 一、时间线与关键里程碑

1. 项目初始化与文档
   - 搭建仓库骨架，添加 `README.md`、`docs/requirements.md`、`docs/architecture.md` 等文档。
2. 引擎 C API 与 stub
   - 添加 `src/engine/include/fr.h`（C ABI），`src/engine/src/fr_stub.cpp`（stub 实现），并为其编写测试。
3. DiskIO 抽象
   - 添加 `src/engine/include/disk_io.h` 与 `src/engine/src/disk_io_stub.cpp`，并为其添加 `src/tests/disk_io_test.cpp`。
4. NTFS 骨架
   - 添加 `src/engine/include/ntfs.h`、`src/engine/include/ntfs_mft.h` 与 stub（`ntfs_stub.cpp`, `ntfs_mft_stub.cpp`）和 `src/tests/ntfs_test.cpp`。
5. 测试依赖 vendor 化
   - 为了避免 CMake FetchContent 的 TLS/证书问题，把 googletest 作为 `src/engine/third_party/googletest` 子模块，并切换到 `release-1.12.1`。
6. 构建脚本与 TLS 绕过
   - `scripts/build_engine.ps1` 支持 `-SkipTlsVerify`（仅用于受控环境），并能自动 configure/build/ctest。
7. Windows 原生 DiskIO 实现
   - 新增 `src/engine/src/disk_io_win.cpp`，使用 `CreateFileA` / `ReadFile`（OVERLAPPED）实现 `DiskIO`，并在 `CMakeLists.txt` 上选择 Windows 实现。
8. 测试失败与诊断
   - 运行测试时出现 0xC0000139（STATUS_ENTRYPOINT_NOT_FOUND）崩溃。诊断显示为运行时 DLL（MinGW 的 libstdc++/libgcc/ pthread）在运行时未找到或版本不匹配。
   - 验证方法：将 `libstdc++-6.dll`, `libgcc_s_seh-1.dll`, `libwinpthread-1.dll` 从 MinGW `bin` 拷贝到 `src/engine/build/` 后，测试通过。
9. 运行时处理策略
   - 不采用静态链接默认（`USE_STATIC_MINGW_RUNTIME` 配置改为 `OFF`）。
   - 选择在运行测试时动态地把 MinGW `bin` 临时 prepended 到 `PATH`（在 `scripts/build_engine.ps1` 中实现），从而避免每次手动拷贝 DLL。

---

## 二、决策与理由

- Vendorize googletest：避免每次 configure 时网络依赖和 TLS 问题，稳定 CI/本地构建。
- 使用 `disk_io_win.cpp`：为了尽快在 Windows 平台上实现原生设备/镜像读取而不是仅依赖 stub。
- 不默认静态链接：保留动态链接（更小的二进制），并通过 PATH 管理运行时依赖；这为开发调试和与系统 CRT 兼容留出灵活度。

---

## 三、已修改或新增的关键文件（摘录）

- `src/engine/include/fr.h` (C API header)
- `src/engine/src/fr_stub.cpp` (engine stub)
- `src/engine/include/disk_io.h` (DiskIO 抽象)
- `src/engine/src/disk_io_stub.cpp` (DiskIO stub)
- `src/engine/src/disk_io_win.cpp` (Windows 原生实现，新增)
- `src/engine/include/ntfs_mft.h`、`src/engine/src/ntfs_mft_stub.cpp`
- `src/engine/src/ntfs_stub.cpp`
- `src/tests/engine_test.cpp`, `src/tests/disk_io_test.cpp`, `src/tests/ntfs_test.cpp`（已修改以使用临时文件进行原生实现测试）
- `src/engine/CMakeLists.txt`（优先使用 vendored googletest；在 Windows 下选择 `disk_io_win.cpp`；增加 `USE_STATIC_MINGW_RUNTIME` 选项，默认 OFF）
- `scripts/build_engine.ps1`（支持 `-SkipTlsVerify`; 在运行测试前自动尝试把 MinGW `bin` 到 `PATH`）

---

## 四、关键命令与重现步骤

1. 配置、构建并运行测试（推荐在项目根）：
```powershell
.\scripts\build_engine.ps1
```
脚本会：计算路径、配置 CMake、构建（Release），并在运行测试时尝试自动把 MinGW 的 bin 目录加入 `PATH`（如果能找到 `g++` 或常见路径）。

2. 如果你的环境没有将 MinGW `bin` 放到 PATH，或者自动探测失败：手动把 MinGW 的运行时 DLL 放到测试二进制同目录（仅作临时验证）：
```powershell
copy D:\green\mingw64\bin\libstdc++-6.dll .\src\engine\build\
copy D:\green\mingw64\bin\libgcc_s_seh-1.dll .\src\engine\build\
copy D:\green\mingw64\bin\libwinpthread-1.dll .\src\engine\build\
```

3. 查看单个测试可执行输出：
```powershell
d:\project\filerecover\src\engine\build\disk_io_tests.exe
d:\project\filerecover\src\engine\build\ntfs_tests.exe
```

---

## 五、构建/测试结果（摘要）

- 初始 configure 时遇到 FetchContent 下载 googletest 的 TLS/证书验证错误（status_code 60），解决方式为 vendorize 或在受控环境下临时设 `CMAKE_TLS_VERIFY=0`。
- 在将 `disk_io_win.cpp` 加入并切换为动态运行时后，测试运行出现 0xC0000139（ENTRYPOINT_NOT_FOUND）。通过把 MinGW 的运行时 DLL 拷贝到测试目录或在测试运行时保证 MinGW `bin` 在 PATH，下列测试均通过：
  - `EngineTests`：通过
  - `DiskIOTests`：通过（测试创建临时文件并从中读取数据）
  - `NTFSParserTests`：通过（NTFS stub + MFT stub 测试）

---

## 六、问题与已做修复（详细）

1) 问题：`disk_io_win.cpp` 一开始使用 `struct DiskIO::Impl` 的嵌套类型声明，但头文件未声明该内部类型，导致编译错误“qualified name does not name a class”。
   - 修复：改为 `DiskIO_Impl` 独立内部实现类型，并调整相应的 static_cast。

2) 问题：测试最初假设 `DiskIO::open()` 总返回 true（stub 行为），但原生实现会依据路径存在性返回 false，因此测试断言失败。
   - 修复：修改 `src/tests/disk_io_test.cpp` 与 `src/tests/ntfs_test.cpp`，在测试中生成真实的临时文件（使用 `std::filesystem` 与 `std::ofstream`），确保原生实现可以打开并读取。

3) 问题：运行时崩溃（0xC0000139），表示某个动态库缺少期望的导出或入口点。
   - 诊断：使用 `objdump -p` 导出可执行导入表，确认导入了 `libstdc++-6.dll`、`libgcc_s_seh-1.dll`、`libwinpthread-1.dll` 以及多个 `api-ms-win-crt-*.dll`。
   - 结果：将 MinGW 的运行时 DLL 拷贝到测试目录后，测试成功运行，结论：崩溃因 MinGW 运行时 DLL 在运行时不可见或版本不匹配所致。
   - 处理策略：不采用默认静态链接；在 `scripts/build_engine.ps1` 中临时把 MinGW `bin` prepended 到 PATH，这是一个开发/测试时的解决方案；CI 中应显式安装 MinGW 或把运行时 DLL 放到可见位置。

---

## 七、当前 TODO 快照（截至 2025-12-22）

- 已完成（关键）：项目搭建、文档、C API stub、DiskIO 抽象与 Windows 实现、NTFS stub、测试、googletest vendor、构建脚本增强、运行时问题诊断与临时修复。
- 待做（优先级）：
  1. CI（GitHub Actions）配置：在 CI 中保证 MinGW 或 MSVC 环境可用、可运行 ctest（高优先）。
  2. NTFS 真实解析器实现（MFT 解析、属性解析、文件名提取）（高优先）。
  3. DiskIO 的生产级增强（直接读取物理设备、异步/缓存策略、错误处理）（中优先）。
  4. 打包与运行时依赖策略（发布时如何处理 MinGW 动态库）（中优先）。

---

## 八、下一步建议（执行性）

1. 在仓库添加 GitHub Actions（Windows 流水线）来复现并固定 MinGW 运行时的可用性；示例策略：在 Windows Runner 上安装 MSYS2/MinGW，或使用预置的 MinGW 环境，确保 PATH 或复制 DLL。此项可先行。
2. 同时开始实现 NTFS MFT 基本解析（做最小可运行实现并覆盖单元测试）。
3. 将 `docs/work_sessions/` 下的会话日志纳入 release notes 或 dev 日志，以便版本回溯。

---

## 九、文件位置与参考

- 本日志文件：`docs/work_sessions/2025-12-22-chat-log.md`
- 构建脚本：`scripts/build_engine.ps1`
- 引擎代码：`src/engine/`（包含 `include/` 与 `src/`）
- 测试：`src/tests/`

---

如果你需要，我可以：
- 把本次日志再细分为“简短要点版”和“逐条消息时间戳版”并存档；
- 立即开始实现 CI（GitHub Actions）草稿并提交为分支/PR；
- 或将日志内容压缩为一页 PDF/Markdown 并创建 release note 草稿。

—— 结束 ——
